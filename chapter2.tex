\chapter{The Erlang/OTP System}\label{ch:erlang_otp_system}

\section{The Erlang Language}\label{sec:erlang_lang}

Erlang is a programming language designed at the Ericsson Computer Science
Laboratory in the 1980’s. It was initially used for developing software for
telecommunications systems. Erlang was released as open source in 1998 and is
mainly being used in domains such as banking, e-commerce, computer telephony
and instant messaging.

The designers of Erlang decided that they wanted a language that would be
suitable for the development of massively scalable and robust distributed
systems that would be fault-tolerant and would ensure high availability.

The scalability and robustness were achieved by having lightweight processes
that conformed to the actor model. When an Erlang process is spawned, it uses a
minimum amount of system resources and can request additional ones as needed.
The actor model suggests that every process can only communicate with one
another process through asynchronous message-passing sent into the receiver’s
mailbox. Every communication is explicit, traceable and safe. This approach
greatly facilitates code debugging in concurrent applications.

Fault tolerance is a controversial topic since it has different meaning to
people. For example, to some it may mean that no process ever fails and no data
is ever lost. However, fault tolerance in Erlang is that the critical core of a
system does not crash. Surely some processes may fail and their data may be
lost but the system will continue to be running despite these events. Adding
the on-the-fly code loading feature to that we get a language that supports the
development of always-on systems.

Erlang is a strict and dynamically-typed language. The programmer is not
obliged to statically annotate his code in any way with type information.
However, type safety is ensured by the runtime environment that catches the
occurring type error, at which point an exception would be raised in the
execution of the program. This allows for more flexible code and is essential
for the fault-tolerant behavior that Erlang provides.

A vital part of the Erlang implementation is the OTP framework. It is a set of
Erlang libraries and design principles providing middle-ware to develop Erlang
applications. It includes its own distributed database, applications to
interface towards other languages, debugging and release handling tools~\cite{erlang_site}.


\section{The Erlang Compiler}\label{sec:erlang_compiler}

Erlang is primarily a compiled language. The code of an application is
organized in modules which are independently compiled and loaded to the runtime
system. The Ericsson Erlang implementation uses a register-based virtual
machine which is called BEAM Virtual Machine as the runtime system. It uses
BEAM bytecode and converts it to threaded code at load time.

The conversion of the textual representation of the Erlang code to BEAM
bytecode is done by the compiler. The first step in this process is to parse
the text file and create the Abstract Syntax Tree (AST) of the module. Erlang
code is quite expressive and has a lot of syntactic sugar in it, therefore a
major transformation occurs that translates the Erlang syntax tree to Core
Erlang syntax tree. Core Erlang is an intermediate high level language that we
will present extensively in the next section. This representation is more
concise with explicit scopes.

The next big transformation is from Core Erlang to the BEAM bytecode
representation. This register-based representation is poorly documented as well
as less comprehensive than Core Erlang, which was one of the reasons why we
wanted to work with Core Erlang rather than BEAM bytecode. The next step is to
run some optimization passes on the bytecode and then convert it to threaded
code and load it to the virtual machine and prepare it for execution.


\section{Core Erlang}\label{sec:core_erlang}

As we mentioned before, Core Erlang is an intermediate representation of
Erlang, which is used by the compiler as a middle-ware tier between the textual
representation of the source code and the intermediate code. It has clear and
simple semantics that allow for a straight forward translation from Erlang code
to Core Erlang code and from Core Erlang code to Intermediate code. It is a
high level but concise language that opts for human readability. It has a
simple grammar thus simplifying the process of pretty printing Core Erlang
programs for humans to read and edit. Its main goal is to facilitate the
development of tools that operate on the Erlang source code, such as profilers,
debuggers, source code optimizers and various programs that perform source code
instrumentations.

The current implementation of the Erlang compiler allows the programmer to
transform his program to the equivalent Core Erlang program and store its
textual representation. He can then read it to inspect or modify the code
transformation or even write some extra Core Erlang code by hand. However,
should he want to execute his code, he must compile it to BEAM bytecode and
then execute it as usual. There is no implementation of a Core Erlang
interpreter, even for debugging purposes, as there is for the Abstract Format
of the Erlang parse trees stored in the debugging information of a module. This
feature was necessary for our implementation, thus a major part of the
development cycle of our tool was dedicated to the creation of a reliable Core
Erlang interpreter.

In the rest of this section, we will provide a brief description of the Core
Erlang Abstract Syntax Tree as it is used in the Erlang compiler and its
semantics.

\subsection{The Core Erlang Abstract Syntax Tree}\label{sub:core_erlang_ast}

The Core Erlang Abstract Syntax Tree has a dual representation in the Erlang
compiler. The core parts of the compiler use the records defined in the file
lib/compiler/core\textunderscore parse.hrl, whereas cerl\textunderscore inline and all the modules in
lib/hipe/cerl use the Abstract Data Type defined in lib/compiler/cerl.erl.
Essentially, both definitions are the same and can be used interchangeably so
the decision on which representation to use boils down to the personal
preference and style of the programmer. The records’ representation allows for
easier decomposition of the syntax tree nodes by using pattern matching whereas
the ADT representation offers a more formal approach that favors parse
transformations. We decided to use the records’ representation as pattern
matching greatly facilitates our implementation of the Core Erlang interpreter.

We feel that since the lexical analysis and grammar of Core Erlang are
presented in detail in the Core Erlang language specification paper, we should
rather present the undocumented definitions of the Core Erlang Abstract Syntax
Tree in lib/compiler/core\textunderscore parse.hrl and discuss their semantics in the context
of their current usage in the Erlang compiler. First of all, let’s note some
principles that will apply for the rest of the subsection and continue to
present the AST records.

\begin{itemize}
  \item A Core Erlang AST is considered to be of type Tree which is a union of
    all the records we will describe.
  \item All the records have the c\textunderscore  prefix.
  \item A special case is the record c\textunderscore def. Well, it is not a record per se,
    but it is mentioned as one in core\textunderscore parse.hrl to denote the type of some
    record fields. It actually is a tuple of two elements, let’s say \{T1, T2\},
    Where T1 and T2 are of type Tree. It is used when we want to show that T1
    is defined by T2. We will see its exact uses as we describe the records in
    core\textunderscore parse.hrl.
  \item Every record has an annotation field which is initialized to the empty
    list. Annotations are a list of associations between constant literals and
    a phrase. They are optional and their interpretation is implementation
    dependent. For simplicity, we will always have an empty annotation list in
    our records.
  \item We will mention the term environment. An environment is simply a
    mapping from names to Erlang values. Every expression is evaluated in a
    given environment that binds variables and functions to their values.
  \item Every evaluation of an expression can terminate normally and yield a
    sequence of values or end unexpectedly and yield an exception.
\end{itemize}

\subsubsection{Root node of a syntax tree}

\includecode[erlang]{lst:core_erlang_c_module}{The \texttt{c\textunderscore module} record definition}{%
  listings/core_erlang_records/c_module.erl
}

The root of a syntax tree will always be a \texttt{c\textunderscore module} record (Listing~\ref{lst:core_erlang_c_module}). The basic unit that
is compiled is a module, a single source code file that consists of the module
name, the list of exported functions, some optional attributes, such as type
definitions and function specifications, and the definitions of the exported
and internal functions. 

As we see, these correspond with the fields of the c\textunderscore module record. The \texttt{name}
field is always a c\textunderscore literal record that holds the name of the module. The
\texttt{exports} field is a list of c\textunderscore var records that hold the names and arities of the
exported functions. The \texttt{attrs} field is a list of the aforementioned c\textunderscore def
constructs. In this case, each c\textunderscore def consists of two c\textunderscore literal records. The
first one denotes the type of attribute (spec, type etc.) and the second one
its definition. The interpretation of module attributes is implementation
specific and we will discuss some of its uses in detail in the chapter <ENTER CHAPTER>. The
\texttt{defs} field is also a list of c\textunderscore def constructs. The
first element of each c\textunderscore def is a c\textunderscore var record
that represents the name and arity of the defined function. The second element
is a c\textunderscore fun record that holds the definition of the respective
function.

\subsubsection{Expressions}

\includecode[erlang]{lst:core_erlang_c_values}{The c\textunderscore values record definition}{%
  listings/core_erlang_records/c_values.erl
}

\emph{Ordered sequence of single expressions} (Listing~\ref{lst:core_erlang_c_values}).
With the term single expression, we mean that we want an expression that its
evaluation will yield to a value. An ordered sequence is the result of
evaluating an expression and is by no means a value per se, meaning that we
cannot have a sequence of sequences. The length of the \texttt{es} list denotes the
degree of the sequence.

\includecode[erlang]{lst:core_erlang_c_literal}{The c\textunderscore literal record definition}{%
  listings/core_erlang_records/c_literal.erl
}

\emph{Atomic literal} (Listing~\ref{lst:core_erlang_c_literal}).
The c\textunderscore literal record holds a  literal and represents the Erlang value denoted
by that literal.


\includecode[erlang]{lst:core_erlang_c_var}{The c\textunderscore var record definition}{%
  listings/core_erlang_records/c_var.erl
}

\emph{Variable name} (Listing~\ref{lst:core_erlang_c_var}).
The \texttt{name} field can be an integer() or an atom() (variable’s name) or a \{atom(),
integer()\} (function’s name and arity). It evaluates to the value that is bound
to the variable or function in the current environment. We should mention that
when it comes to a function, the value that we expect is a closure.


\includecode[erlang]{lst:core_erlang_c_tuple}{The c\textunderscore tuple record definition}{%
  listings/core_erlang_records/c_tuple.erl
}

\emph{Erlang tuple} (Listing~\ref{lst:core_erlang_c_tuple}).
The c\textunderscore tuple record holds a list of n expressions. This evaluates to the Erlang
n-tuple where each element is the result of the evaluation of the respective
expression of the \texttt{es} list in the current environment. If the \texttt{es} field is an
empty list, then the result is the 0-tuple \{\}.


\includecode[erlang]{lst:core_erlang_c_cons}{The c\textunderscore cons record definition}{%
  listings/core_erlang_records/c_cons.erl
}

\emph{Erlang list constructor} (Listing~\ref{lst:core_erlang_c_cons}).
The \texttt{hd} field is the expression that evaluates to the head of the cons cell and
the \texttt{tl} field is the expression that evaluates to the tail of the cons cell. The
environment in which these evaluations occur is the current environment of the
c\textunderscore cons.


\includecode[erlang]{lst:core_erlang_c_binary}{The c\textunderscore binary record definition}{%
  listings/core_erlang_records/c_binary.erl
}

\emph{Erlang binary} (Listing~\ref{lst:core_erlang_c_binary}).
The \texttt{segments} field is a list of c\textunderscore bitstr records that each evaluates to an Erlang
bitstring. The value of the c\textunderscore binary is the concatenation of these individual
bitstrings in the order defined in the segments list. All the segments are
evaluated in same environment as the c\textunderscore binary record.


\includecode[erlang]{lst:core_erlang_c_bitstr}{The c\textunderscore bitstr record definition}{%
  listings/core_erlang_records/c_bitstr.erl
}

\emph{Erlang bitstring} (Listing~\ref{lst:core_erlang_c_bitstr}).
The \texttt{val} field specifies a value to be encoded as a bitstring, whereas the rest
of the fields control the encoding and are the template of the bitstring. These
control fields are evaluated at load time so they ought to be c\textunderscore literal
records. This limitation has complicated the implementation of the Core Erlang
interpreter and its effect will be discussed at the chapter <ENTER CHAPTER>.
The \texttt{size} field is evaluated either to a non negative integer or to the atom
\texttt{‘all’}. The \texttt{unit} field evaluates to number between 1 and 256. The \texttt{type} field
evaluates to either integer, float or binary. The \texttt{flags} field evaluates to a
list that contains a value for the signedness (signed or unsigned) and a value
for the endianess (big, little or native) of the bitstring. The specifics of
the encoding will be discussed when we present the Erlang Type System in
chapter <ENTER CHAPTER>.

\includecode[erlang]{lst:core_erlang_c_let}{The c\textunderscore let record definition}{%
  listings/core_erlang_records/c_let.erl
}

\emph{Let definition} (Listing~\ref{lst:core_erlang_c_let}).
First of all, we evaluate the expression that is held in the \texttt{arg} field in the
current environment \texttt{e}. This evaluation yields sequence of \texttt{n} values \texttt{s}. We then
expect a list of n c\textunderscore var records in the \texttt{vars} field that represent the variables
that are to be bound. We then bind these variables to their respective value in
the sequence /texttt{s} and add them to the current environment \texttt{e} thus creating the new
environment \texttt{e’}. The value of the whole let expression is the evaluation of the
expression of the \texttt{body} field in the new environment \texttt{e’}.


\includecode[erlang]{lst:core_erlang_c_seq}{The c\textunderscore seq record definition}{%
  listings/core_erlang_records/c_seq.erl
}

\emph{Sequence of expressions} (Listing~\ref{lst:core_erlang_c_seq}).
This record is syntactic sugar for a c\textunderscore let without an
\texttt{vars} field. Its only purpose is to evaluate the expression of the
\text{arg} field before the expression of the \texttt{body} field. Both
expressions are evaluated in the current environment.

\includecode[erlang]{lst:core_erlang_c_case}{The c\textunderscore case record definition}{%
  listings/core_erlang_records/c_case.erl
}

\emph{Case statement} (Listing~\ref{lst:core_erlang_c_case}).
This is the main control flow construct (along with c\textunderscore receive). We begin with
evaluating the expression of the \texttt{arg} field in the current environment which
yields a sequence of values. Then, this sequence is matched against each of the
clauses in the \texttt{clauses} field list until one of them succeeds. It is certain
that at least one will succeed since the compiler adds a catch-all clause at
the end of every non-exhaustive case statement that will raise the appropriate
exception. The order of the clauses is important since only the first one that
matched will be selected. For what happens when a clause is selected, refer to
the explanation of the c\textunderscore clause record.


\includecode[erlang]{lst:core_erlang_c_fun}{The c\textunderscore fun record definition}{%
  listings/core_erlang_records/c_fun.erl
}

\emph{Function definition} (Listing~\ref{lst:core_erlang_c_fun}).
The \texttt{vars} field containts a list of c\textunderscore var records that denote the parameters of
the function. The \texttt{body} field contains an expression that defines the body of
the function. This record is used to define three types of functions.

\begin{itemize}
  \item An exported or internal function of a model
  \item An anonymous function
  \item A function that is bound in a letrec statement
\end{itemize}

In all three cases, it evaluates to the closure that is defined by abstracting
the expression in the \texttt{body} field with respect to the parameters in the \texttt{vars}
field in the current environment.


\includecode[erlang]{lst:core_erlang_c_letrec}{The c\textunderscore letrec record definition}{%
  listings/core_erlang_records/c_letrec.erl
}

\emph{Letrec statement} (Listing~\ref{lst:core_erlang_c_letrec}).
We must note that only functions can be bound by a Core Erlang letrec
statement. Therefore, the c\textunderscore def we encounter in \texttt{defs} field list has a c\textunderscore var as
its first element that denotes the name and arity of the function that is to be
bound. The second element is a c\textunderscore fun record that holds the definition of the
particular function. Once we bind all the functions to their definitions and
add them to the current environment \texttt{e}, we evaluate the expression of the \texttt{body}
field in the resulting environment \texttt{e’}.

The definition of \texttt{e’} can be a little tricky. The environment \texttt{e’} is the smallest
environment such that:

\begin{itemize}
  \item contains all the elements of \texttt{e}, except for the functions that will be
    bound by the letrec,
  \item and every such function will be evaluated in \texttt{e’} itself.
\end{itemize}

This is a circular definition and its implementation requires a recursive
environment. Essentially, we need an environment that arranges to evaluate the
values for its bindings in an environment where the bindings are already in
place. We will discuss how we implemented this feature in the chapter <ENTER
CHAPTER>.

\includecode[erlang]{lst:core_erlang_c_apply}{The c\textunderscore apply record definition}{%
  listings/core_erlang_records/c_apply.erl
}

\emph{Function application} (Listing~\ref{lst:core_erlang_c_apply}).
The \texttt{op} field contains the expression that will evaluate to a closure \texttt{f} in the
current environment. The \texttt{args} field contains a list of n expressions that will
evaluate to \texttt{n} values respectively that will comprise the argument list of the
closure. The result of the expression is the application of the argument list
to the closure \texttt{f}. It is expected that the arity of the closure \texttt{f} will be the
same as the length of the argument list.


\includecode[erlang]{lst:core_erlang_c_call}{The c\textunderscore call record definition}{%
  listings/core_erlang_records/c_call.erl
}

\emph{Inter-module function call} (Listing~\ref{lst:core_erlang_c_call}).
The \texttt{module} and \texttt{name} fields contain the information of the function with an
explicit module, function name, and arity (MFA) that will be called. The both
evaluate to atoms. The \texttt{args} field contains a list of expressions that each is
evaluated in the current environment. The resulting list of values will be
passed as the argument list of the MFA. It is essential that the MFA is in its
module’s exported list.


\includecode[erlang]{lst:core_erlang_c_primop}{The c\textunderscore primop record definition}{%
  listings/core_erlang_records/c_primop.erl
}

\emph{Primitive Operation} (Listing~\ref{lst:core_erlang_c_primop}).
The \texttt{args} field contains a list of expressions that are evaluated in the current
environment and yield a list of values respectively. The \texttt{name} field contains
the primitive operation (mainly a c\textunderscore var) to be performed. We then apply the
list of values to the primitive operator to get the value of the whole
expression.

The evaluation of a primitive operation is implementation dependent and may
depend on many things, like the internal state of the process, the external
state of the world etc. A common area that primitive operations are used in is
bit comprehensions.

\includecode[erlang]{lst:core_erlang_c_try}{The c\textunderscore try record definition}{%
  listings/core_erlang_records/c_try.erl
}

\emph{Try–catch statement} (Listing~\ref{lst:core_erlang_c_try}).
The \texttt{arg} field contains the main expression that we will try to evaluate
in the current environment \texttt{e}. Depending on the result of this
evaluation we have two alternatives:

\begin{enumerate}
  \item The evaluation completes normally and yields a sequence of values.
    Then, we bind these values to the list of variables contained in the
    \texttt{vars} field and add these bindings to \texttt{e} thus creating the
    environment \texttt{e'}. The result of the try-catch expression is the result of the evaluation of the expression of the \texttt{body} field in the environment \texttt{e'}.
  \item The evaluation stops abruptly raising an exception. Then, we bind the
    exception to the list of variables contained in the \texttt{evars} field
    and add these bindings to \texttt{e} thus creating the environment
    \texttt{e''}. The result of the try-catch expression is the result of the evaluation of the expression of the \texttt{handler} field in the environment \texttt{e''}.
\end{enumerate}


\includecode[erlang]{lst:core_erlang_c_catch}{The c\textunderscore catch record definition}{%
  listings/core_erlang_records/c_catch.erl
}

\emph{Catch statement} (Listing~\ref{lst:core_erlang_c_catch}).
This is syntactic sugar for a c\textunderscore try with only the \texttt{body} field. This works as follows:
We evaluate the \texttt{body} expression in the current environment and monitor its evaluation. There are two alternatives:

\begin{enumerate}
  \item If the evaluation completed normally, the value of the whole expression is the value of the \texttt{body}.
  \item If the evaluation stops abruptly and yields an exception, we do one of the following:
    \begin{enumerate}
      \item If it is a \texttt{throw} exception, we return the reason of the
        exception \texttt{r}.
      \item If it is an \texttt{exit} exception, we return the reason of the
        exception \texttt{r} wrapped in the tuple \texttt{\{'EXIT', r\}}.
      \item If it is an \texttt{error} exception, we return the reason of the
        exception \texttt{r} along with the stacktrace \texttt{s} wrapped in
        the tuple \texttt{\{'EXIT', r, s\}}.
    \end{enumerate}
\end{enumerate}

\includecode[erlang]{lst:core_erlang_c_receive}{The c\textunderscore receive record definition}{%
  listings/core_erlang_records/c_receive.erl
}

\emph{Receive expression} (Listing~\ref{lst:core_erlang_c_receive}).
This is the second type of control flow construct that exists in Core Erlang.
Its evaluation is a bit complex thus is divided into stages.

\begin{enumerate}
  \item The \texttt{timeout} field contains the expiry expression, which the
    first thing we evaluate in the current environment \texttt{e}. It may yield a non
    negative integer \texttt{t} or the atom \texttt{'infinity'}. If the result
    is not \texttt{'infinity'}, we start a timer that expires in \texttt{t}
    milliseconds.
  \item\label{itm:recv-stage-2} Then, we run through the process's mailbox from start to end and we try
    to match a message agains one of the clauses in the \texttt{clauses} list
    field in the current environment \texttt{e}. This may have two outcomes:
    \begin{enumerate}
      \item A message matches one of the clauses and yields some mappings that
        added to \texttt{e} create the environment \texttt{e'}. Then, this
        message is atomically deleted from the mailbox and we evaluate the
        expression indicated by the matched clause in the environment \texttt{e'}.
      \item We tried all the current messages but none matched any of the
        clauses. If the expiry expression evaluated to 0 or the timer has
        expired, we evaluate the expression of the \texttt{action} field in
        \texttt{e}. Otherwise, we suspend the evaluation and continue to the
        next stage.
    \end{enumerate}
  \item The evaluation is recovered if a message has arrived to the mailbox or
    if the timer has expired. In the former scenario we re-enter stage~\ref{itm:recv-stage-2},
    whereas in the latter one we evaluate the expression of the \texttt{action}
    field in \texttt{e}.
\end{enumerate}

\subsubsection{Clauses and Pattern Matching}

\includecode[erlang]{lst:core_erlang_c_clause}{The c\textunderscore clause record definition}{%
  listings/core_erlang_records/c_clause.erl
}

\emph{Clause template} (Listing~\ref{lst:core_erlang_c_clause}).
This records describes the template of a Core Erlang clause. The \texttt{pats}
field contains the sequence of patterns that will be tried, in left-to-right order,
against the sequence of values so as to determine if the clause matches the
sequence. The patterns are evaluated in the current environment \texttt{e}.

\begin{itemize}
  \item If the patterns and the sequence of values matched, some new bindings
    may have been generated which added to \texttt{e} will create the new
    environment \texttt{e'}. We then evalute the expression of the
    \texttt{guard} field. 
    \begin{itemize}
      \item If the result is \texttt{'true'}, the clause has been definitively
        matched thus we continue to evaluate the expression of the
        \texttt{body} field in the environment \texttt{e'}.
      \item If the result is \texttt{'false'}, the clause does not match so we
        move on to the next clause.
    \end{itemize}
  \item If the patterns did not match the sequence, the next clause in order is
    tried.
\end{itemize}

A pattern is represented by the following records:

\begin{itemize}
  \item A \texttt{c\textunderscore literal} record represents an atomic literal pattern.
  \item A \texttt{c\textunderscore var} record represents a variable name pattern.
  \item A \texttt{c\textunderscore tuple} record represents a tuple pattern.
  \item A \texttt{c\textunderscore cons} record represents a list constructor pattern.
  \item A \texttt{c\textunderscore binary} record represents a binary pattern.
  \item A \texttt{c\textunderscore alias} record (Listing~\ref{lst:core_erlang_c_alias}) represents an alias pattern.
    The \texttt{pat} field contains the pattern that will be matched against a
    value \texttt{v}. If the match succeeds then a mapping is generated that
    binds the variable of the \texttt{var} field to \texttt{v}. If not, the
    whole match fails.
\end{itemize}


\includecode[erlang]{lst:core_erlang_c_alias}{The c\textunderscore alias record definition}{%
  listings/core_erlang_records/c_alias.erl
}


